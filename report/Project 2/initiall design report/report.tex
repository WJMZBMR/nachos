\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings, xcolor}
\usepackage{graphicx,float,wrapfig}
\newcommand{\Class}{Operation System}
\newcommand{\ClassInstructor}{Wei Xu}
\newcommand{\Break}{\State \textbf{break} }

% Homework Specific Information. Change it to your own

% In case you need to adjust margins:
\topmargin=-0.45in      %
\evensidemargin=0in     %
\oddsidemargin=0in      %
\textwidth=6.5in        %
\textheight=9.0in       %
\headsep=0.25in         %

% Setup the header and footer                                 %

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Some tools

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Make title
\title{Project 2 - Initial Design Document}
\author{Chen Lijie\\ \and
	Fan Haoqiang\\ \and
	Bi Ke\\ }
\date{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
	\maketitle
	\tableofcontents
	\section{Our git Repository}
	\texttt{https://github.com/wjmzbmr/nachos}
	\newpage
	\section{Implementation of System calls for File System}
	\subsection{A simple illustration}
	Since in class FileSystem, we only have method open() and remove(), which means we need to implement unlink on our own by keeping a counter for each file opened.
	\subsection{Correctness Invariants}
	\subsection{Declaration}
	\subsubsection*{UserProcess}
	\begin{itemize}
		\item A static member processCounter, keeps the number of each process.
		\item A final member maxBuf, which is the maximum buffer size per read.
		\item A member processId.
		\item An array fileList of OpenFile with size 16 to store the opened file.
		\item Modification in UserProcess(), which set file Descriptor 0 and 1 to stdin and stdout.
		\item Modification in handleHalt()
		\item New methods: handleCreate(), handleOpen(), handleRead(), handleWrite(), handleClose(), handleUnlink(). With specified functionality in the task.
	\end{itemize}
	\subsubsection*{UserKernel}
	\begin{itemize}
		\item A class FileManager, which keeps a counter for each file and whether it should be unlinked.
		\item A static subclass of FileManager, FileRecord, with two fields: counter and unlinked.
		\item A HashMap map in FileManager, map the file's name to the FileRecord.
		\item A Lock mutex in FileManager, ensuring that only one process can access to it.
		\item method open(), create(), unlink() and close() in FileManager, which will change the information for each file.
	\end{itemize}
	\subsection{Description}
	The pseudo code follows:
	\subsubsection*{UserProcess}
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {UserProcess()}{}
			\State Disable Interruption
			\State processId $\leftarrow$ processCounter++
			\State fileList $\leftarrow$ new OpenFile[16]
			\State fileList[0] $\leftarrow$ UserKernel.console.openForReading()
			\State fileList[1] $\leftarrow$ UserKernel.console.openForWriting()
			\State Restore Interruption
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {handleHalt()}{}
			\If{processId != 0}
			\State \Return -1
			\EndIf
			\State Machine.halt()
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {handleCreate(adr)}{}
			\State file $\leftarrow$ readVirtualMemoryString(adr,256)
			\If{file == null}
			\State \Return -1
			\EndIf
			\State idx $\leftarrow$ 0
			\While{idx $<$ 16 AND fileList[idx] != null}
			\State idx++
			\EndWhile
			\If{idx == 16}
			\State \Return -1
			\EndIf
			\If{NOT UserKernel.FileManager.create(file)}
			\State \Return -1
			\EndIf
			\State openFile $\leftarrow$ UserKernel.fileSystem.open(file,true)
			\If{openFile == null}
			\State \Return -1
			\EndIf
			\State fileList[idx] $\leftarrow$ openFile
			\State \Return idx
			\EndProcedure
		\end{algorithmic}
	%\end{algorithm}
	
	%QUESTION: the behavior of open and create when unlinked
	%\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {handleOpen()}{}
			\State file $\leftarrow$ readVirtualMemoryString(adr,256)
			\If{file == null}
			\State \Return -1
			\EndIf
			\State idx $\leftarrow$ 0
			\While{idx $<$ 16 AND fileList[idx] != null}
			\State idx++
			\EndWhile
			\If{idx == 16}
			\State \Return -1
			\EndIf
			\If{NOT UserKernel.FileManager.open(file)}
			\State \Return -1
			\EndIf
			\State openFile $\leftarrow$ UserKernel.fileSystem.open(file,false)
			\If{openFile == null}
			\State \Return -1
			\EndIf
			\State fileList[idx] $\leftarrow$ openFile
			\State \Return idx
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {handleRead(idx,adr,buf)}{}
			\If{idx is invalid OR adr is valid OR fileList[idx] is null}
			\State \Return -1
			\EndIf
			\State file $\leftarrow$ fileList[idx]
			\While{buf $>$ 0}
			\State toRead $\leftarrow$ min(buf,maxBuf)
			\State read toRead bytes from file, and write it to adr
			\If{if in above an error occur}
			\State \Return -1
			\EndIf
			\State buf $\leftarrow$ buf - toRead
			\EndWhile
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {handleWrite(idx,adr,buf)}{}
			\If{idx is invalid OR adr is valid OR fileList[idx] is null}
			\State \Return -1
			\EndIf
			\State file $\leftarrow$ fileList[idx]
			\While{buf $>$ 0}
			\State toRead $\leftarrow$ min(buf,maxBuf)
			\State read toRead bytes from adr, and write it to the file
			\If{if in above an error occur}
			\State \Return -1
			\EndIf
			\State buf $\leftarrow$ buf - toRead
			\EndWhile
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {handleClose(idx)}{}
			\If{idx is invalid}
			\State \Return -1
			\EndIf
			\State file $\leftarrow$ fileList[idx]
			\State name $\leftarrow$ file.getName()
			\State file.close()
			\State fileList[idx] $\leftarrow$ null
			\If{UserKernel.FileManager.close(name)}
			\State \Return 0
			\Else
			\State \Return -1
			\EndIf
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {handleUnlink(adr)}{}
			\If{adr is invalid}
			\State \Return -1
			\EndIf
			\State file $\leftarrow$ readVirtualMemoryString(adr,256)
			\If{file == null}
			\State \Return -1
			\EndIf
			\If{UserKernel.FileManager.unlink(file)}
			\State \Return 0
			\EndIf
			\State \Return -1
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	\subsubsection*{UserKernel}
	
	In class FileManager
	
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {FileRecord()}{}
			\State unlinked $\leftarrow$ false
			\State counter $\leftarrow$ 0
			\EndProcedure
		\end{algorithmic}
		\begin{algorithmic}
			\Procedure {FileManager()}{}
			\State map $\leftarrow$ new HashMap$<$String,FileRecord$>$()
			\EndProcedure
		\end{algorithmic}
		\begin{algorithmic}
			\Procedure {create(file)}{}
			\State mutex.acquire()
			\If{NOT map.containsKey(file)}
			\State record $\leftarrow$ new FileRecord()
			\State record.counter++
			\State map.put(file,record)
			\State mutex.release()
			\State \Return true
			\Else
			\State record $\leftarrow$ map.get(file)
			\If{record.unlinked}
			\State mutex.release()
			\State \Return false
			\EndIf
			\State record.counter++
			\State mutex.release()
			\State \Return true
			\EndIf
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
    \begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {open(file)}{}
			\State mutex.acquire()
			\If{NOT map.containsKey(file)}
			\State mutex.release()
			\State \Return false
			\Else
			\State record $\leftarrow$ map.get(file)
			\If{record.unlinked}
			\State mutex.release()
			\State \Return false
			\EndIf
			\State record.counter++
			\State mutex.release()
			\State \Return true
			\EndIf
			\EndProcedure
		\end{algorithmic}
		\begin{algorithmic}
			\Procedure {close(file)}{}
			\State mutex.acquire()
			\If{NOT map.containsKey(file)}
			\State mutex.release()
			\State \Return false
			\Else
			\State record $\leftarrow$ map.get(file)
			\State record.counter$--$
			\If{record.counter == 0 AND record.unlinked}
			\State UserKernel.fileSystem.remove(file)
			\State map.remove(file)
			\EndIf
			\State mutex.release()
			\State \Return true
			\EndIf
			\EndProcedure
		\end{algorithmic}
		\begin{algorithmic}
			\Procedure {unlink(file)}{}
			\State mutex.acquire()
			\If{NOT map.containsKey(file)}
			\State mutex.release()
			\State \Return false
			\Else
			\State record $\leftarrow$ map.get(file)
			\If{record.counter == 0}
			\State UserKernel.fileSystem.remove(file)
			\State map.remove(file)
			\Else
			\State record.unlinked $\leftarrow$ true
			\EndIf
			\State mutex.release()
			\State \Return true
			\EndIf
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	\subsection{Description of Tests}
	\section{Implementation of Support for Multiprogramming}
	\subsection{A simple illustration}
	Use a double linked list to maintain the currently available pages. So that we can make use of them efficiently.
	\subsection{Correctness Invariants}
	\subsection{Declaration}
	\subsubsection*{UserKernel}
	\begin{itemize}
		\item A linked list of Integer avaPages, which stores the currently available pages.
		\item A lock pagesMutex, which prevents multiple process from using the avaPages.
	\end{itemize}
	\subsubsection*{UserProcess}
	\begin{itemize}
		\item Modifications in readVirtualMemory() and writeVirtualMemory().
		\item Modifications in loadSections()
		\item Modifications in unloadSections()
		\item Modifications in the constructor of UserKernel, which initialize the list of avaPages.
	\end{itemize}
	
	\subsection{Description}
	The pseudo code follows:
	\subsubsection*{UserKernel}
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {UserKernel()}{}
			\State pagesMutex $\leftarrow$ new Lock()
			\While{avaPages.size() $<$ numPhypages}
			\State avaPages.add(new page)
			\EndWhile
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	\subsubsection*{UserProcess}
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {readVirtualMemory(vaddr,data,offset,length)}{}
			\If{vaddr is not valid}
			\State \Return 0
			\EndIf
			\State length $\leftarrow$ min(length, numPages * pageSize - vaddr)
			\State total $\leftarrow$ 0
			\State begin $\leftarrow$ Machine.process.pageFromAddress(vaddr)
			\State end $\leftarrow$ Machine.process.pageFromAddress(vaddr + length - 1)
			\For{page $\leftarrow$ begin to end}
			\If{page is invalid}
			\State \Return total
			\EndIf
			\State read the corresponding bytes in page to data[offset..]
			\State update total and offset
			\EndFor
			\State \Return total
			\EndProcedure
		\end{algorithmic}
		\begin{algorithmic}
			\Procedure {writeVirtualMemory(vaddr,data,offset,length)}{}
			\If{vaddr is not valid}
			\State \Return 0
			\EndIf
			\State length $\leftarrow$ min(length, numPages * pageSize - vaddr)
			\State total $\leftarrow$ 0
			\State begin $\leftarrow$ Machine.process.pageFromAddress(vaddr)
			\State end $\leftarrow$ Machine.process.pageFromAddress(vaddr + length - 1)
			\For{page $\leftarrow$ begin to end}
			\If{page is invalid}
			\State \Return total
			\EndIf
			\State write the corresponding bytes in data[offset..] to the page
			\State update total and offset
			\EndFor
			\State \Return total
			\EndProcedure
		\end{algorithmic}
		\begin{algorithmic}
			\Procedure {loadSections()}{}
			\State UserKernel.pagesMutex.acquire()
			\If{the avaPages.size() $<$ numPages}
			\State UserKernel.pagesMutex.release()
			\Return false
			\EndIf
			\State pageTable $\leftarrow$ new TranslationEntry[numPages]
			\For{i $\leftarrow$ 0 to numPages - 1}
			\State page $\leftarrow$ avaPages.poll()
			\State pageTable[i] $\leftarrow$ new TranslationEntry(i,page,true,false,false,false)
			\EndFor
			\State UserKernel.pagesMutex.release()
			\State ...
			\State vpn $\leftarrow$ section.getFirstVPN()+i;
			\State pageTable[vpn].readOnly $\leftarrow$ section.isReadOnly()
			\State section.loadPage(i, vpn);
			\State ..
			\State \Return true
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
    \begin{algorithm}[H]
		\begin{algorithmic}
			\Procedure {unloadSections()}{}
			\State UserKernel.pagesMutex.acquire()
			\State add all pages in pageTable to avaPages
			\State UserKernel.pagesMutex.release()
			\State close all those files opened in fileList
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	\subsection{Description of Tests}
	\section{Implementation of System calls exec, join and exit}
	\subsection{Correctness Invariants}
	\subsection{Declaration}
	\begin{itemize}
		\item 
	\end{itemize}
	\subsection{Description}
	\subsection{Description of Tests}
	\section{Implementation of LotteryScheduler}
	\subsection{A simple illustration}
	\subsection{Correctness Invariants}
	\subsection{Declaration}
	\subsection{Description}
	\subsection{Description of Tests}
\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

